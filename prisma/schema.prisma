// prisma/schema.prisma
// This Prisma schema file defines all tables.columns that shall exist in db
// The first version of this file was created automatically by 'npx prisma init'

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model AuthUser {
  // maintains data delivered continually from the auth0-based authentication method in a synch fashion.  
  // field below called 'auth0Id' (called 'sub' in the incoming auth0 object) is a string that is the the unique Id from Auth0
  id              Int         @id @default(autoincrement())
  auth0Id         String      @unique         @map("auth0_id") // 101: this @map specifies the exact name of the field to be created/written to in PostgresQL.  without this, Prisma will create all kinds of funky names in PSQL. 
  email           String      // 2025jun21: removed unique constraint on email, b/c we will accept (then manage) "identity collision" being sent to us from auth0
  emailVerified   Boolean     @default(false) @map("email_verified")
  name            String?     // 101: no @map needed here, b/c it's a single world all lower case.  Prisma will create it simply as-is in psql. 
  givenName       String?     @map("given_name")
  familyName      String?     @map("family_name")
  nickname        String?
  picture         String?
  createdAt       DateTime    @default(now()) @map("created_at")
  updatedAt       DateTime    @updatedAt      @map("updated_at")

  userProfile     UserProfile? // 101: 'userProfile' on this line is an alias to the UserProfile object table

  duplicateOfId   Int?        @map("duplicateof_id")
  duplicateOf     AuthUser?   @relation("DuplicateRelation", fields: [duplicateOfId], references: [id])
  duplicates      AuthUser[]  @relation("DuplicateRelation")

  @@map("auth_user") // 101: this @map specifies the exact name of the table to be created/written to in PostgresQL.  without this, Prisma will create all kinds of funky names in PSQL. 
}

model UserProfile {
  // 1:1 relationship to an authUser record. 
  // records herein created once by auth0 sync process; after initial record creation, data does not again get written from authUser record. 
  // maintains data about the end user; 
  // this record the true "end user" account to which all down-stream activity is linked, such as groups, rsvps, etc.  
  id              Int         @id @default(autoincrement())
  userId          Int?        @unique         @map("user_id")
  altEmail        String?     @map("alt_email")     
  altNickname     String?     @map("alt_nickname")  // 2025may05: this *was* a deprecated field, to be whacked.  But then it got repurposed to be "family brand name"
  phone           String?
  slugDefault     String      @unique         @map("slug_default")
  slugVanity      String?     @unique         @map("slug_vanity")
  createdAt       DateTime    @default(now()) @map("created_at")
  updatedAt       DateTime    @updatedAt      @map("updated_at")
  givenName       String?     @map("given_name")     
  familyName      String?     @map("family_name")   

  authUser        AuthUser?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  rsvps           Rsvp[]              // RSVP responses
  chapterMembership  ChapterMember[]     // join to Chapters

  @@map("user_profile")
}

model LoginFailure {
  // 
  id            Int      @id @default(autoincrement()) @map("id")
  presentableId String   @unique                      @map("presentable_id")
  createdAt     DateTime @default(now())              @map("created_at")
  errorCode     String?                               @map("error_code")
  email         String?                               @map("email")
  auth0Id       String?                               @map("auth0_id")
  verifyEmailResent       Boolean?  @default(false)   @map("verify_email_resent")

  @@map("login_error")
}

model AuthUserUserProfileSwapAudit {
  // This entity captures (1) all the id and foreign key fields that are affected by the authUser-userProfile swap processs, as well as (2) those fields which are closely related to that process.  
  // There are four authUser / userProfile records edited in the swap process: 
  // (1) "promoted" authUser: the authUser record that *was* in dupe/notUsable status, which is getting PROMOTED to primary/usable status
  // (2) "demoted" authUser: the authUser record that *was* primary/usable, which is getting DEMOTED to dupe/notUsable status
  // (3) "maintained" userProfile: the userProfile record that was primary/usable, ***which is being maintained*** for primary/continued use
  // (4) "precluded" userProfile: the userProfile record that is unuseable (b/c it was paired to a dupe/notUserable authUser record). This record will continue to be unusable.  (keep reading for how...) 
  // The swap activity does two very closely related things: 
  // (A) transform what has been the "dupe" authUser record into the primary authUser record (i.e. promotion), by nulling its duplicateof_id field. 
  // ... then conversely, transform what has been the "primary" authUser record into a dupe (i.e. demotion), by populating its duplicateof_id field with the id of the aforementioned now primary authUser
  // (B) switch the historical/maintained userProfile record FROM pairing to the newly-demoted authUser record TO pairing to the newly-promoted authUser record, 
  // ... and doing this by updating its user_profile.user_id field
  // ... then conversely, switch the precluded userProfile record FROM pairing to the newly-promoted authUser record TO pairing to the newly-demoted authUser record
  // ... and doing this by updating its user_profile.user_id field

  // below is the unique ID for this swap action/audit record
  id                                         Int      @id @default(autoincrement()) @map("id")
  // Below are captured for present and future sanity. Email is an essential join, and auth0id basically tells you the *type* of authentication record we're dealing with: 
  // googleSocial v. emailPassword v. (etc.)
  promotedAuthUserEmail                      String?     @map("promoted_auth_user_email")           // SOURCE_TABLE.FIELD: auth_user.email
  demotedAuthUserEmail                       String?      @map("demoted_auth_user_email")           // SOURCE_TABLE.FIELD: auth_user.email
  promotedAuthUserAuth0Id                    String?   @map("promoted_auth_user_auth0_id")     // SOURCE_TABLE.FIELD: auth_user.auth0_id 
  demotedAuthUserAuth0Id                     String?   @map("demoted_auth_user_auth0_id")     // SOURCE_TABLE.FIELD: auth_user.auth0_id 

  // below field collection represents the promoted authUser record
  promotedAuthUserId                         Int?      @map("promoted_auth_user_id")           // SOURCE_TABLE.FIELD: auth_user.id 
  promotedAuthUserDuplicateOfIdInitial       Int?      @map("promoted_auth_user_duplicateof_id_initial") // SOURCE_TABLE.FIELD: auth_user.duplicateof_id 
  // NOTE: above field will have a value, b/c this authUser record was the dupe originally 
  promotedAuthUserDuplicateOfIdPost          Int?      @map("promoted_auth_user_duplicateof_id_post")    // SOURCE_TABLE.FIELD: auth_user.duplicateof_id 
  // NOTE: above field will be NULL, b/c the swap activity is making this authUser record into the primary record

  // below field collection represents the demoted authUser record
  demotedAuthUserId                       Int?      @map("demoted_auth_user_id")           // SOURCE_TABLE.FIELD: auth_user.id 
  demotedAuthUserDuplicateOfIdInitial     Int?      @map("demoted_auth_user_duplicateof_id_initial") // SOURCE_TABLE.FIELD: auth_user.duplicateof_id 
  // NOTE: above field will be NULL, b/c the intial value is null: this was the primary authUser record
  demotedAuthUserDuplicateOfIdPost        Int?      @map("demoted_auth_user_duplicateof_id_post")    // SOURCE_TABLE.FIELD: auth_user.duplicateof_id 
  // NOTE: above field will have a value, b/c this authUser record is being demoted / set as dupe. 

  // below field collection represents the maintained userProfile record
  maintainedUserProfileId                      Int?      @map("maintained_user_profile_id")           
  maintainedUserProfileUserIdInitial          Int?      @map("maintained_user_profile_user_id_initial")           
  maintainedUserProfileUserIdInitialPost      Int?      @map("maintained_user_profile_user_id_post")           

  // put differently: before the swap activty, this userProfile record was useless (b/c it was tied to a dupe authUser record), 
  // ... and after the swap activity, this userProfile record will again be usesless, but now it will be tied to the newly demoted dupe authUser record.
  precludedUserProfileId                      Int?     @map("precluded_user_profile_id")           
  precludedUserProfileUserIdInitial           Int?     @map("precluded_user_profile_userid_initial")     
  precludedUserProfileUserIdInitialPost       Int?     @map("precluded_user_profile_userid_post")  

  createdAt    DateTime       @default(now()) @map("created_at")

  @@map("authuser_userprofile_swap_audit")
}

model Chapter {
  id              Int                 @id @default(autoincrement())
  name            String? 
  description     String?
  createdAt       DateTime            @default(now()) @map("created_at")
  updatedAt       DateTime            @updatedAt @map("updated_at")
  slug            String              @unique // 2025jul31 added. 
  
  members      ChapterMember[]  
  events       Event[]

  // future fields: 
  // location     String? // 2025jul30: leave this out for now, might do differently.  possibly: geography?  
  // status       String?     array: Active/Inactive
    @@map("chapter")
}

model ChapterMember {
  id              Int              @id @default(autoincrement())
  chapterId       Int              @map("chapter_id")
  userProfileId   Int              @map("user_profile_id")
  memberRole      MemberRole       @map("member_role") @default(MEMBER)
  joinedAt        DateTime         @default(now()) @map("joined_at")

  chapter         Chapter          @relation(fields: [chapterId], references: [id])
  userProfile     UserProfile      @relation(fields: [userProfileId], references: [id])

  @@unique([chapterId, userProfileId]) // each user_profile can only appear once per chapter
  @@map("chapter_member")

  // future fields: 
  // status       String?     array: Active/Inactive/Pending

  // something to handle application and decision process for each would-be chapterMember
  // leaveReason  String?     array: voluntary; removed; other?  
  // also, maybe a table to handle membership actions: applied; approved; denied; removed; blocked; 
  // bear in mind per our business design: there is no "invite users to chapter" program: no fishing for users! 
}

enum MemberRole {
  MEMBER
  MANAGER
  BLOCKED
}

model Event {
  id              Int               @id @default(autoincrement())
  chapterId       Int               @map("chapter_id")
  title           String?
  description     String?
  presentableId   String            @unique   @map("presentable_id")

  // Google Maps data
  placeId         String?           @map("place_id") // from Google Place Details API
  venueName       String?           @map("venue_name") // e.g. "Johnny's Ice House West"
  address         String?           // full formatted address
  lat             Float?            // optional: for map pins
  lng             Float?            // optional

  // time info
  startsAt        DateTime?          @map("starts_at") // from Google Place Details API// UTC preferred
  durationMin     Int?               @map("duration_min") // total minutes

  createdAt       DateTime           @default(now()) @map("created_at")
  updatedAt       DateTime           @updatedAt @map("updated_at")

  chapter         Chapter            @relation(fields: [chapterId], references: [id])
  rsvps           Rsvp[]     

  @@map("event")
  // future fields: 
  // createdBy       lookup to userProfile.  need to track this, display it
  // stuff about rsvp cap, etc. 
  // status       String?     array: Active/Cancelled
}

model Rsvp {
  id              Int                 @id @default(autoincrement())
  eventId         Int                 @map("event_id")           
  
  // optional: populated for member rsvps, null for ad hoc rsvps 
  userProfileId   Int?                @map("user_profile_id") 
  
  // optional: null for member rsvps, populated for ad hoc rsvps
  name            String?             
  email           String?             
  slug            String?             @unique 

  rsvpStatus      RsvpStatus?          @map("rsvp_status")
  createdAt       DateTime            @default(now()) @map("created_at")
  updatedAt       DateTime            @updatedAt @map("updated_at")

  event          Event                @relation(fields: [eventId], references: [id])
  userProfile    UserProfile?         @relation(fields: [userProfileId], references: [id])
  
  @@map("rsvp")
  // future fields: 
  // createdBy       lookup to userProfile.  need to track this, display it
  // respondedAt     DateTime?           @map("responded_at")    // set when user responds?? 
  // count of on-ice kids
  // count of on-ice adults
  // attributes about volunteering, i.e. music, team captain, referee, photographer, etc. 
}

enum RsvpStatus {
  YES
  NO
  MAYBE
}

// design rules when making a new table: 
// all id look like this: id           Int              @id @default(autoincrement())
// only require fields when absolutely necessary in db; handle soft requirement in validation
// camel-case fields must have an @map for declared db field name
// createdAt always required, barring major exception
// all createdAt looks like this: createdAt    DateTime         @default(now()) @map("created_at")
// updatedAt required for table whose records are prone to frequent changing
// all updatedAt looks like this: updatedAt    DateTime         @updatedAt @map("updated_at")
// all relationship attributes at the bottom
// camel-case table name must have an @@map for declared table name